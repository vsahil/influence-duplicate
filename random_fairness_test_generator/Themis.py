# Target 1: generate test cases just for 1 feature, in this case gender which is feature no 0 - Done
# Target 2: Increase the number of test cases generated by:     - DONE
#           a. Increasing the sampling threshold    - removed out of picture
#           b. Increasing the max sampling -- increasing this increases the no of tests by same factor - DONE
#           c. Do not break out of the loop when generating values of all inputs, in the causal.py file - DONE
# Target 3: Port this code to Python3 - DONE
# Target 4: integrate this with the trained model for german credit dataset.


import sys
import itertools
# import commands
import subprocess
import random
import math
import causal
import group



class soft:
    causalDiscrimination = causal.causalDiscrimination
    groupDiscrimination  = group.groupDiscrimination
    ProcessCacheCausal   = causal.ProcessCacheCausal
    ProcessCache         = group.ProcessCache
    conf_zValue          = {80:1.28,  90:1.645,  95:1.96,  98:2.33,  99:2.58}

    MaxSamples        = 1000
    SamplingThreshold = MaxSamples * 10        # to remove the computation which you don't want, just remove this knob out of the picture of tunable parameters, set to a very high value 
    cache             = {}

    def __init__(self, names, values, num, command, type_discm):
        self.attr_names = names
        self.values = values
        self.num = num
        self.type = type_discm
        self.command = command
        self.causal_tests = []      # These tests are for a feature we are testing and are pairwise inputs (tests)
    
    
    def getValues(self):
        return self.values

    
    def getComand(self):
        return self.command
    
    
    def getAttributeNames(self):
        return self.attr_names
    
    
    # Get the number of values that a particular attribute can take
    def getRange(self, attr_name):
        for index,att_name in self.attr_names.iteritems():
            if(att_name == attr_name):
                return self.num[index]

    
	# Gets the different values a particular attribute can take
    def getValues(self, attr_name):
        for index,att_name in self.attr_names.iteritems():
            if(att_name == attr_name):
                return self.values[index]

    
    def printSoftwareDetails(self):
        print("Number of attributes are ", len(self.attr_names),"\n")
        i = 0
        while i<len(self.attr_names):
            print("Attribute name is ", self.attr_names[i])
            print("Number of values taken by this attribute =", self.getRange(self.attr_names[i]))
            print("The different values taken are ", self.getValues(self.attr_names[i]), "\n")
            i += 1

    
    # Basically for each attribute generate a random value within its range
    def randomInput(self, I, X, attr):
        i = 0
        inp = []
        while i < len(I):
            if i in X:
                inp.append(attr[X.index(i)])
            else:
                inp.append(random.randint(0, I[i]-1))	# choose randomly
            i += 1
        return inp

    
    
    
    # def SoftwareTest(self, inp,num, values):
    #     i=0
    #     actual_inp = []
    #     running_command = self.command
        
    #     while i < len(inp):
    #         actual_inp.append(values[i][inp[i]])
    #         running_command += " "
    #         running_command += str(values[i][inp[i]])
    #         i += 1
        
    #     rc = running_command.split()        # split into a list and send it
    #     result = subprocess.check_output(rc)
    #     result = result.decode("utf-8").rstrip()
    #     # print(type(result), result, result == "0", result == "1")
    #     return result == "1"
        # return commands.getstatusoutput(running_command)[1] == "1"


    def decodeValues(self, index, num, X):
        attr=[]
        copy = index
        for x in X:
            a = num[x]
            attr.append(copy%a)
            copy -= (copy%a)
            copy = copy/a
        return attr


    def SoftwareTest(self, inp, num, values):
        i=0
        actual_inp = []
        running_command = self.command
        # import ipdb; ipdb.set_trace()
        arguments = ''
        while i < len(inp):
            actual_inp.append(values[i][inp[i]])
            arguments += str(values[i][inp[i]])
            if i < len(inp) - 1:
                arguments += ", "
            i += 1
        
        rc = running_command.split()        # split into a list and send it
        rc.append(arguments)
        result = subprocess.check_output(rc)
        # import ipdb; ipdb.set_trace()
        result = result.decode("utf-8").rstrip()       # convert binary to str
        print(type(result), result, result[-1] == "0", result[-1] == "1")
        # print(result)
        return result, result[-1] == "1"


    def randomInput_gender0(self, discm_feature):
        inp = []
        for i in range(len(self.attr_names)):
            if not i == discm_feature:
                inp.append(int(random.choice(self.values[i]))) 
            else:
                inp.append(0)       # this is for gender 0
        return inp


    def single_feature_discm(self, feature, theta, confidence, epsilon, type_discm):
        assert(isinstance(feature, int))
        assert(feature <= len(self.attr_names))
        # score = self.causalDiscrimination([feature], confidence, epsilon)
        # print("No. of discriminating tests: ", len(self.causal_tests), "Score: ", score)
        discm_tests_gender0 = []
        total = 0
        while True:
            new = self.randomInput_gender0(feature)
            # if not new in discm_tests_gender0:      # its fine for 2 or more tests to be identical, we generate it randomly
            discm_tests_gender0.append(new)
            total += 1
            x = len(discm_tests_gender0) 
            # if x == 1000000:
            if x == self.MaxSamples:
                print(total, "hello")
                with open("gender0_adult_mini.csv", "a") as f:
                    for i in discm_tests_gender0:
                        f.write(str(i)[1:-1] + "\n")
                discm_tests_gender0 = []
            
            # if total == 45222*100:
            if total == self.MaxSamples:                
                with open("gender0_adult_mini.csv", "a") as f:
                    for i in discm_tests_gender0:
                        f.write(str(i)[1:-1] + "\n")
                break

        # check if any tests are duplicated:
        # df = pd.read_csv("gender0_adult.csv")
        # x = df.duplicated()
        # x.any()     # if this is False, we are all good.
        # np.where(x) # if this is an empty list we are good, For adult we are good.
        
        # This generates same examples for the other gender
        # df = pd.read_csv("gender0_adult_mini.csv")
        # df['sex'] = 1
        # df.to_csv("gender1_adult_mini.csv", index=False)
        
        # with open("gender0_adult.csv", "a") as f:
        #     for i in discm_tests_gender0:
        #         f.write(str(i)[1:-1] + "\n")

        # if score > theta:
            # print("Discriminates against: ", self.attr_names[feature])

    # theta is discrimination threshold
    # epsilon is the error margin, with some confidence value. I want to keep max confidence and lowest error to generate a lot of tests.
        
    def discriminationSearch(self, theta, confidence, epsilon, type_discm):
        Scausal=[]
        if "causal" in type_discm and "group" in type_discm:
            Scausal = self.discriminationSearch(theta, confidence, epsilon, "causal")
		
		# lst = []
        # i = 0
		# while i < len(self.attr_names):
		#     lst.append(i)
		#     i += 1
		
        lst = [i for i in range(len(self.attr_names))]
		
        i = 1
        D = []
		# iteratively generates subsets of 1, 2, 3 ... length upto the total number of attributes
		# import ipdb; ipdb.set_trace()
		
        while i <= len(self.attr_names):
            subsets = list(itertools.combinations(tuple(lst), i))
            for X in subsets:
                found = False
                for d in D:         # this is using theorems 4.1 and 4.2 from the paper, if the subset is already there don't evaluate the superset
                    if set(d) < set(list(X)):
                        found = True
                        break
                if found:       # this found is for sound pruning
                    continue
                if "group" in type_discm:
                    score = self.groupDiscrimination(list(X), confidence, epsilon)
                elif "causal" in type_discm:
                    score = self.causalDiscrimination(list(X), confidence, epsilon)
                if score > theta:
                    D.append(list(X))       # for each of group and causal if the score is greater then theta then append that list to D, this list can be later will be used for comparsion as well

            i += 1
		
		# this just substitutes number in the dictionary for their attribute names
        S = []
        for d in D:
            s = []
            for att in d:
                s.append(self.attr_names[att])
            S.append(s)
		# this is just for printing for the user on screen, which type of discrimination and how much
	
        if "group" in type_discm and "causal" in type_discm:
            dict={"group":S, "causal":Scausal["causal"]}

        elif "group" in type_discm:
            dict={"group":S}

        else:
            dict={"causal":S}

        return dict



    def getTestSuite(self):
        inp_lst = []
        # print(self.values)
        for inp, out in self.cache.iteritems():
            curr = []
            i = 0
            while i < len(inp):
                curr.append(self.values[i][inp[i]])
                i += 1
            inp_lst.append(curr)

        return len(inp_lst)
